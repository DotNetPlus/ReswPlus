using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using ReswPlus.Core.ResourceParser;
using ReswPlus.SourceGenerator.ClassGenerators.Models;
using ReswPlus.SourceGenerator.Models;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace ReswPlus.SourceGenerator.CodeGenerators;

/// <summary>
/// Generates C# code for strongly-typed resources using Roslyn SyntaxFactory.
/// </summary>
/// <remarks>
/// This class converts resource files and localization keys into a strongly-typed class
/// that exposes methods or properties for each resource key. It also creates a XAML markup
/// extension class to allow for resource binding in XAML. The generated source code is well-formatted,
/// includes generated attributes, and organizes each resource member within region directives.
/// </remarks>
/// <example>
/// The generated code may look similar to the following:
/// <code language="csharp">
/// // File generated automatically by ReswPlus. https://github.com/DotNetPlus/ReswPlus
/// using System;
/// using Windows.UI.Xaml.Markup;
/// using Windows.UI.Xaml.Data;
/// 
/// namespace MyApp.Resources {
///     [global::System.CodeDom.Compiler.GeneratedCodeAttribute("ReswPlus", "1.0.0.0")]
///     [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
///     [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
///     public static class MyResources {
///         private static _ReswPlus_AutoGenerated.ResourceStringProvider _resourceStringProvider;
/// 
///         static MyResources() {
///             _resourceStringProvider = new _ReswPlus_AutoGenerated.ResourceStringProvider("MyResourceFile.resw");
///         }
/// 
///         public static string GetString(string key) => _resourceStringProvider.GetString(key);
/// 
///         #region WelcomeMessage
///         /// <summary>
///         /// This is the welcome message.
///         /// </summary>
///         public static string WelcomeMessage {
///             get { return _resourceStringProvider.GetString("WelcomeMessage"); }
///         }
///         #endregion
/// 
///         // Additional generated members...
///     }
/// }
/// </code>
/// </example>
internal sealed class CSharpCodeGenerator : ICodeGenerator
{
    /// <summary>
    /// Generates a collection of files containing the source code.
    /// </summary>
    /// <param name="baseFilename">The base filename for the generated file.</param>
    /// <param name="info">Contains information about the strongly-typed class and its localization items.</param>
    /// <param name="resourceFileInfo">Contains information about the resource file.</param>
    /// <returns>A collection of generated files.</returns>
    public IEnumerable<GeneratedFile> GetGeneratedFiles(string? baseFilename, StronglyTypedClass info, ResourceFileInfo resourceFileInfo)
    {
        // Create a header comment that will be placed at the top of the generated file.
        var headerTrivia = TriviaList(
            Comment("// File generated automatically by ReswPlus. https://github.com/DotNetPlus/ReswPlus"),
            CarriageReturnLineFeed
        );

        // Build the compilation unit (the root node of a C# file) and add required using directives.
        var compilationUnit = CompilationUnit()
            .WithLeadingTrivia(headerTrivia)
            .WithUsings(List(GetUsings(info.AppType)));

        // Create the strongly-typed static class declaration (the class that will provide resource lookup).
        var strongClassDecl = CreateStronglyTypedClass(info);

        // For each localization item, generate members (properties or methods) that return localized strings.
        var formatMembers = new List<MemberDeclarationSyntax>();
        foreach (var item in info.Items)
        {
            // Generate one or more member declarations for the given localization key.
            var membersForItem = CreateFormatMethodSyntax(item).ToList();

            // Instead of using simple comment trivia, create structured region directives for better readability.
            for (int i = 0; i < membersForItem.Count; i++)
            {
                // Create a #region directive with the key name.
                var regionDirectiveTrivia = SyntaxFactory.Trivia(
                    SyntaxFactory.RegionDirectiveTrivia(isActive: true)
                        .WithEndOfDirectiveToken(
                            SyntaxFactory.Token(
                                leading: SyntaxFactory.TriviaList(),
                                kind: SyntaxKind.EndOfDirectiveToken,
                                text: " " + item.Key,
                                valueText: " " + item.Key,
                                trailing: SyntaxFactory.TriviaList(SyntaxFactory.ElasticCarriageReturnLineFeed)
                            )
                        )
                );
                // Create an #endregion directive.
                var endRegionDirectiveTrivia = SyntaxFactory.Trivia(
                    SyntaxFactory.EndRegionDirectiveTrivia(isActive: true)
                        .WithEndOfDirectiveToken(
                            SyntaxFactory.Token(
                                leading: SyntaxFactory.TriviaList(),
                                kind: SyntaxKind.EndOfDirectiveToken,
                                text: string.Empty,
                                valueText: string.Empty,
                                trailing: SyntaxFactory.TriviaList(SyntaxFactory.ElasticCarriageReturnLineFeed)
                            )
                        )
                );
                // Attach the region directives as leading and trailing trivia.
                membersForItem[i] = membersForItem[i]
                    .WithLeadingTrivia(SyntaxFactory.TriviaList(regionDirectiveTrivia))
                    .WithTrailingTrivia(SyntaxFactory.TriviaList(endRegionDirectiveTrivia));
            }
            formatMembers.AddRange(membersForItem);
        }
        // Add the generated members (format methods/properties) to the strongly-typed class.
        strongClassDecl = strongClassDecl.AddMembers(formatMembers.ToArray());

        // Create the markup extension class that allows resource keys to be used in XAML.
        var markupExtensionDecl = CreateMarkupExtensionSyntax(info.ResoureFile, info.ClassName + "Extension", info.Items.Select(x => x.Key));

        // If a namespace is provided, wrap the classes in a namespace declaration.
        if (info.Namespaces != null && info.Namespaces.Any())
        {
            var nsName = string.Join(".", info.Namespaces);
            var namespaceDecl = NamespaceDeclaration(ParseName(nsName))
                .AddMembers(strongClassDecl, markupExtensionDecl);
            compilationUnit = compilationUnit.AddMembers(namespaceDecl);
        }
        else
        {
            // Otherwise, add the classes at the root level.
            compilationUnit = compilationUnit.AddMembers(strongClassDecl, markupExtensionDecl);
        }

        // Normalize the whitespace (formatting) and return the generated source code.
        var code = compilationUnit.NormalizeWhitespace().ToFullString();
        yield return new GeneratedFile(baseFilename + ".cs", code);
    }

    /// <summary>
    /// Returns a collection of using directives based on the application type.
    /// </summary>
    private IEnumerable<UsingDirectiveSyntax> GetUsings(AppType appType)
    {
        var usings = new List<UsingDirectiveSyntax>
        {
            UsingDirective(ParseName("System"))
        };

        if (appType == AppType.WindowsAppSDK)
        {
            usings.Add(UsingDirective(ParseName("Microsoft.UI.Xaml.Markup")));
            usings.Add(UsingDirective(ParseName("Microsoft.UI.Xaml.Data")));
        }
        else
        {
            usings.Add(UsingDirective(ParseName("Windows.UI.Xaml.Markup")));
            usings.Add(UsingDirective(ParseName("Windows.UI.Xaml.Data")));
        }

        return usings;
    }

    /// <summary>
    /// Creates the strongly-typed resource class.
    /// This class is static, contains generated attributes, a private resource provider field,
    /// a static constructor to initialize it, and a GetString method to retrieve strings.
    /// </summary>
    private ClassDeclarationSyntax CreateStronglyTypedClass(StronglyTypedClass info)
    {
        // Define attributes for the generated class.
        var assemblyName = "ReswPlus"; // This can be determined dynamically.
        var version = "1.0.0.0";
        var attributes = List(
        [
            AttributeList(
                SingletonSeparatedList(
                    Attribute(ParseName("global::System.CodeDom.Compiler.GeneratedCodeAttribute"))
                    .WithArgumentList(
                        AttributeArgumentList(
                            SeparatedList<AttributeArgumentSyntax>(new SyntaxNodeOrToken[]
                            {
                                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(assemblyName))),
                                Token(SyntaxKind.CommaToken),
                                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(version)))
                            }))))
            ),
            AttributeList(SingletonSeparatedList(Attribute(ParseName("global::System.Diagnostics.DebuggerNonUserCodeAttribute")))),
            AttributeList(SingletonSeparatedList(Attribute(ParseName("global::System.Runtime.CompilerServices.CompilerGeneratedAttribute"))))
        ]);

        // Create a private static field: _resourceStringProvider.
        var resourceField = FieldDeclaration(
                VariableDeclaration(ParseTypeName("_ReswPlus_AutoGenerated.ResourceStringProvider"))
                .WithVariables(SingletonSeparatedList(
                    VariableDeclarator(Identifier("_resourceStringProvider"))
                )))
            .WithModifiers(TokenList(
                Token(SyntaxKind.PrivateKeyword),
                Token(SyntaxKind.StaticKeyword)
            ));

        // Create a static constructor that initializes the _resourceStringProvider.
        var staticCtor = ConstructorDeclaration(info.ClassName)
            .WithModifiers(TokenList(Token(SyntaxKind.StaticKeyword)))
            .WithBody(Block(
                ExpressionStatement(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        IdentifierName("_resourceStringProvider"),
                        ObjectCreationExpression(ParseTypeName("_ReswPlus_AutoGenerated.ResourceStringProvider"))
                            .WithArgumentList(
                                ArgumentList(
                                    SingletonSeparatedList(
                                        Argument(
                                            LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(info.ResoureFile))
                                        )
                                    )
                                )
                            )
                    )
                )
            ));

        // Create a simple GetString method that returns the string for a given key.
        var getStringMethod = MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), "GetString")
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword)
            ))
            .WithParameterList(
                ParameterList(
                    SingletonSeparatedList(
                        Parameter(Identifier("key"))
                        .WithType(PredefinedType(Token(SyntaxKind.StringKeyword)))
                    )
                )
            )
            .WithExpressionBody(
                ArrowExpressionClause(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName("_resourceStringProvider"),
                            IdentifierName("GetString")
                        )
                    ).WithArgumentList(
                        ArgumentList(
                            SingletonSeparatedList(
                                Argument(IdentifierName("key"))
                            )
                        )
                    )
                )
            )
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));

        // Build and return the complete class declaration.
        var classDecl = ClassDeclaration(info.ClassName)
            .WithAttributeLists(attributes)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.StaticKeyword)
            ))
            .AddMembers(resourceField, staticCtor, getStringMethod);

        return classDecl;
    }

    /// <summary>
    /// Generates one or more member declarations (property or method overloads)
    /// for a given localization item.
    /// </summary>
    private IEnumerable<MemberDeclarationSyntax> CreateFormatMethodSyntax(Localization item)
    {
        var members = new List<MemberDeclarationSyntax>();

        // Create XML documentation for the member using the summary from the localization item.
        var summaryText = item.Summary ?? string.Empty;
        var xmlComment = TriviaList(
            Trivia(
                DocumentationCommentTrivia(SyntaxKind.SingleLineDocumentationCommentTrivia,
                    List(new XmlNodeSyntax[]
                    {
                        // Leading "/// " text.
                        XmlText().WithTextTokens(
                            TokenList(XmlTextLiteral("/// "))
                        ),
                        // The summary element.
                        XmlElement(
                            XmlElementStartTag(XmlName("summary")),
                            XmlElementEndTag(XmlName("summary"))
                        ).WithContent(
                            List(new XmlNodeSyntax[]
                            {
                                XmlText().WithTextTokens(TokenList(XmlTextLiteral(summaryText)))
                            })
                        )
                    })
                )
            )
        );

        if (item.IsProperty)
        {
            // Generate a property: public static string {Key} { get { return ... } }
            var propertyDecl = PropertyDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier(item.Key))
                .WithModifiers(TokenList(
                    Token(SyntaxKind.PublicKeyword),
                    Token(SyntaxKind.StaticKeyword)
                ))
                .WithLeadingTrivia(xmlComment)
                .WithAccessorList(
                    AccessorList(
                        SingletonList(
                            AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                            .WithBody(Block(GenerateFormatMethodBody(item)))
                        )
                    )
                );
            members.Add(propertyDecl);
        }
        else
        {
            // Build the parameter list from regular parameters and any extra parameters.
            var functionParameters = item.Parameters.OfType<FunctionFormatTagParameter>().ToList();
            if (item.ExtraParameters != null && item.ExtraParameters.Any())
            {
                functionParameters.InsertRange(0, item.ExtraParameters);
            }

            // If any parameter is marked as a variant, generate an overload that uses 'object'.
            if (functionParameters.Any(p => p.IsVariantId))
            {
                // Create parameters for the overload.
                var overloadParameters = SeparatedList<ParameterSyntax>(
                    functionParameters.Select(p =>
                        Parameter(Identifier(p.Name))
                        .WithType(p.IsVariantId ? PredefinedType(Token(SyntaxKind.ObjectKeyword)) : GetParameterTypeSyntax(p.Type))
                    )
                );

                // Build the inner call arguments, converting variant parameters if needed.
                var innerArguments = SeparatedList<ArgumentSyntax>(
                    functionParameters.Select(p =>
                        Argument(
                            p.IsVariantId
                            ? InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName("Convert"),
                                    IdentifierName("ToInt64")
                                ),
                                ArgumentList(SingletonSeparatedList(Argument(IdentifierName(p.Name))))
                              )
                            : IdentifierName(p.Name)
                        )
                    )
                );

                // Create a method overload that wraps the call in a try-catch.
                var overloadMethod = MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier(item.Key))
                    .WithModifiers(TokenList(
                        Token(SyntaxKind.PublicKeyword),
                        Token(SyntaxKind.StaticKeyword)
                    ))
                    .WithParameterList(ParameterList(overloadParameters))
                    .WithLeadingTrivia(xmlComment)
                    .WithBody(
                        Block(
                            // try { return {Key}(...); } catch { return string.Empty; }
                            TryStatement(
                                Block(
                                    SingletonList<StatementSyntax>(
                                        ReturnStatement(
                                            InvocationExpression(IdentifierName(item.Key))
                                            .WithArgumentList(ArgumentList(innerArguments))
                                        )
                                    )
                                ),
                                List(
                                [
                                    CatchClause()
                                    .WithBlock(
                                        Block(
                                            SingletonList<StatementSyntax>(
                                                ReturnStatement(
                                                    MemberAccessExpression(
                                                        SyntaxKind.SimpleMemberAccessExpression,
                                                        IdentifierName("string"),
                                                        IdentifierName("Empty")
                                                    )
                                                )
                                            )
                                        )
                                    )
                                ]),
                                null
                            )
                        )
                    );
                members.Add(overloadMethod);

                // Also create the standard method with proper parameter types.
                var stdParameters = SeparatedList<ParameterSyntax>(
                    functionParameters.Select(p =>
                        Parameter(Identifier(p.Name))
                        .WithType(GetParameterTypeSyntax(p.Type))
                    )
                );
                var stdMethod = MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier(item.Key))
                    .WithModifiers(TokenList(
                        Token(SyntaxKind.PublicKeyword),
                        Token(SyntaxKind.StaticKeyword)
                    ))
                    .WithParameterList(ParameterList(stdParameters))
                    .WithLeadingTrivia(xmlComment)
                    .WithBody(Block(GenerateFormatMethodBody(item)));
                members.Add(stdMethod);
            }
            else
            {
                // If no variant parameter exists, create a single method.
                var parametersList = SeparatedList<ParameterSyntax>(
                    functionParameters.Select(p =>
                        Parameter(Identifier(p.Name))
                        .WithType(GetParameterTypeSyntax(p.Type))
                    )
                );
                var methodDecl = MethodDeclaration(PredefinedType(Token(SyntaxKind.StringKeyword)), Identifier(item.Key))
                    .WithModifiers(TokenList(
                        Token(SyntaxKind.PublicKeyword),
                        Token(SyntaxKind.StaticKeyword)
                    ))
                    .WithParameterList(ParameterList(parametersList))
                    .WithLeadingTrivia(xmlComment)
                    .WithBody(Block(GenerateFormatMethodBody(item)));
                members.Add(methodDecl);
            }
        }
        return members;
    }

    /// <summary>
    /// Generates the statements for the body of a format method.
    /// This method builds an expression to look up a localized string, optionally
    /// performing formatting via string.Format if formatting parameters exist.
    /// </summary>
    private IEnumerable<StatementSyntax> GenerateFormatMethodBody(Localization item)
    {
        // Determine the key to use when retrieving the resource.
        ExpressionSyntax keyExpr;
        if (item is IVariantLocalization variantLoc && variantLoc.ParameterToUseForVariant != null)
        {
            // If the item supports variants, concatenate the key with the variant parameter.
            keyExpr = BinaryExpression(
                SyntaxKind.AddExpression,
                LiteralExpression(SyntaxKind.StringLiteralExpression, Literal($"{item.Key}_Variant")),
                IdentifierName(variantLoc.ParameterToUseForVariant.Name)
            );
        }
        else
        {
            // Otherwise, just use the key as-is.
            keyExpr = LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(item.Key));
        }

        // Build the expression that retrieves the localized string.
        ExpressionSyntax localizationExpr;
        if (item is PluralLocalization pluralLoc && pluralLoc.ParameterToUseForPluralization != null)
        {
            // For plural localization, call the GetPlural method.
            ExpressionSyntax pluralParamExpr = IdentifierName(pluralLoc.ParameterToUseForPluralization.Name);
            if (pluralLoc.ParameterToUseForPluralization.TypeToCast.HasValue)
            {
                // Cast the parameter if needed.
                pluralParamExpr = ParenthesizedExpression(
                    CastExpression(
                        GetParameterTypeSyntax(pluralLoc.ParameterToUseForPluralization.TypeToCast.Value),
                        IdentifierName(pluralLoc.ParameterToUseForPluralization.Name)
                    )
                );
            }
            localizationExpr = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    ParseExpression("_ReswPlus_AutoGenerated.Plurals.ResourceLoaderExtension"),
                    IdentifierName("GetPlural")
                ),
                ArgumentList(SeparatedList(
                [
                    Argument(IdentifierName("_resourceStringProvider")),
                    Argument(keyExpr),
                    Argument(pluralParamExpr),
                    Argument(LiteralExpression(pluralLoc.SupportNoneState ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression))
                ]))
            );
        }
        else
        {
            // For non-plural strings, call GetString.
            localizationExpr = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("_resourceStringProvider"),
                    IdentifierName("GetString")
                ),
                ArgumentList(SingletonSeparatedList(Argument(keyExpr)))
            );
        }

        // If formatting parameters are provided, wrap the localization string in string.Format.
        if (item.Parameters != null && item.Parameters.Any())
        {
            var formatArgs = SeparatedList(
                item.Parameters.Select<IFormatTagParameter, ExpressionSyntax>(p =>
                {
                    switch (p)
                    {
                        case FunctionFormatTagParameter funcParam:
                            return IdentifierName(funcParam.Name);
                        case MacroFormatTagParameter macroParam:
                            return MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                ParseExpression("_ReswPlus_AutoGenerated.Macros"),
                                IdentifierName(macroParam.Id)
                            );
                        case LiteralStringFormatTagParameter literalParam:
                            return LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(literalParam.Value));
                        case StringRefFormatTagParameter stringRefParam:
                            return IdentifierName(stringRefParam.Id);
                        default:
                            return LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(string.Empty));
                    }
                })
            );

            // Call string.Format(localizationExpr, new object[] { ... });
            var formatInvocation = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName("string"),
                    IdentifierName("Format")
                ),
                ArgumentList(SeparatedList(
                [
                    Argument(localizationExpr),
                    Argument(
                        ArrayCreationExpression(
                            ArrayType(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                                .WithRankSpecifiers(
                                    SingletonList(
                                        ArrayRankSpecifier(
                                            SingletonSeparatedList<ExpressionSyntax>(
                                                OmittedArraySizeExpression()
                                            )
                                        )
                                    )
                                )
                        )
                        .WithInitializer(
                            InitializerExpression(
                                SyntaxKind.ArrayInitializerExpression,
                                formatArgs
                            )
                        )
                    )
                ]))
            );
            yield return ReturnStatement(formatInvocation);
        }
        else
        {
            // No formatting parameters: simply return the localization string.
            yield return ReturnStatement(localizationExpr);
        }
    }

    /// <summary>
    /// Converts a ParameterType enum value to its corresponding C# type.
    /// </summary>
    private TypeSyntax GetParameterTypeSyntax(ParameterType type)
    {
        var keyword = type switch
        {
            ParameterType.Byte => SyntaxKind.ByteKeyword,
            ParameterType.Int => SyntaxKind.IntKeyword,
            ParameterType.Uint => SyntaxKind.UIntKeyword,
            ParameterType.Long => SyntaxKind.LongKeyword,
            ParameterType.String => SyntaxKind.StringKeyword,
            ParameterType.Double => SyntaxKind.DoubleKeyword,
            ParameterType.Char => SyntaxKind.CharKeyword,
            ParameterType.Ulong => SyntaxKind.ULongKeyword,
            ParameterType.Decimal => SyntaxKind.DecimalKeyword,
            _ => SyntaxKind.ObjectKeyword,
        };

        return PredefinedType(Token(keyword));
    }

    /// <summary>
    /// Creates a markup extension class that can be used in XAML for resource lookup.
    /// This class includes an embedded KeyEnum, a static resource provider field,
    /// a static constructor, properties for Key, Converter, ConverterParameter, and
    /// a ProvideValue method override.
    /// </summary>
    private ClassDeclarationSyntax CreateMarkupExtensionSyntax(string resourceFileName, string className, IEnumerable<string> keys)
    {
        var assemblyName = "ReswPlus";
        var version = "1.0.0.0";
        var attributes = List(
        [
            AttributeList(
                SingletonSeparatedList(
                    Attribute(ParseName("global::System.CodeDom.Compiler.GeneratedCodeAttribute"))
                    .WithArgumentList(
                        AttributeArgumentList(
                            SeparatedList<AttributeArgumentSyntax>(new SyntaxNodeOrToken[]
                            {
                                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(assemblyName))),
                                Token(SyntaxKind.CommaToken),
                                AttributeArgument(LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(version)))
                            })
                        )
                    )
                )
            ),
            AttributeList(SingletonSeparatedList(Attribute(ParseName("global::System.Diagnostics.DebuggerNonUserCodeAttribute")))),
            AttributeList(SingletonSeparatedList(Attribute(ParseName("global::System.Runtime.CompilerServices.CompilerGeneratedAttribute")))),
            AttributeList(
                SingletonSeparatedList(
                    Attribute(ParseName("MarkupExtensionReturnType"))
                    .WithArgumentList(
                        AttributeArgumentList(
                            SingletonSeparatedList(
                                AttributeArgument(
                                    NameEquals(IdentifierName("ReturnType")),
                                    null,
                                    TypeOfExpression(PredefinedType(Token(SyntaxKind.StringKeyword)))
                                )
                            )
                        )
                    )
                )
            )
        ]);

        // Build the KeyEnum that lists all available resource keys.
        var enumMembers = new List<EnumMemberDeclarationSyntax>
        {
            // The default _Undefined member with value 0.
            EnumMemberDeclaration(Identifier("_Undefined"))
            .WithEqualsValue(EqualsValueClause(LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(0))))
        };
        foreach (var key in keys)
        {
            enumMembers.Add(EnumMemberDeclaration(Identifier(key)));
        }
        var keyEnum = EnumDeclaration("KeyEnum")
            .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
            .WithMembers(SeparatedList(enumMembers));

        // Create a private static field for the resource provider.
        var resourceField = FieldDeclaration(
                VariableDeclaration(ParseTypeName("_ReswPlus_AutoGenerated.ResourceStringProvider"))
                .WithVariables(SingletonSeparatedList(
                    VariableDeclarator(Identifier("_resourceStringProvider"))
                ))
            )
            .WithModifiers(TokenList(
                Token(SyntaxKind.PrivateKeyword),
                Token(SyntaxKind.StaticKeyword)
            ));

        // Create the static constructor for the markup extension class.
        var staticCtor = ConstructorDeclaration(className)
            .WithModifiers(TokenList(Token(SyntaxKind.StaticKeyword)))
            .WithBody(Block(
                ExpressionStatement(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        IdentifierName("_resourceStringProvider"),
                        ObjectCreationExpression(ParseTypeName("_ReswPlus_AutoGenerated.ResourceStringProvider"))
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(
                                        LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(resourceFileName))
                                    )
                                )
                            )
                        )
                    )
                )
            ));

        // Create the ProvideValue method that returns the resource string (possibly using a converter).
        var provideValueMethod = MethodDeclaration(PredefinedType(Token(SyntaxKind.ObjectKeyword)), "ProvideValue")
            .WithModifiers(TokenList(
                Token(SyntaxKind.ProtectedKeyword),
                Token(SyntaxKind.OverrideKeyword)
            ))
            .WithBody(Block(
                // Declare a local variable 'value' that checks if the key is _Undefined.
                LocalDeclarationStatement(
                    VariableDeclaration(ParseTypeName("var"))
                    .WithVariables(SingletonSeparatedList(
                        VariableDeclarator(Identifier("value"))
                        .WithInitializer(
                            EqualsValueClause(
                                ConditionalExpression(
                                    BinaryExpression(
                                        SyntaxKind.EqualsExpression,
                                        IdentifierName("Key"),
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName("KeyEnum"),
                                            IdentifierName("_Undefined")
                                        )
                                    ),
                                    LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(string.Empty)),
                                    InvocationExpression(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName("_resourceStringProvider"),
                                            IdentifierName("GetString")
                                        )
                                    )
                                    .WithArgumentList(
                                        ArgumentList(
                                            SingletonSeparatedList(
                                                Argument(
                                                    InvocationExpression(
                                                        MemberAccessExpression(
                                                            SyntaxKind.SimpleMemberAccessExpression,
                                                            IdentifierName("Key"),
                                                            IdentifierName("ToString")
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        )
                    ))
                ),
                // Return the value. If a Converter is set, call Converter.Convert.
                ReturnStatement(
                    ConditionalExpression(
                        BinaryExpression(
                            SyntaxKind.IsExpression,
                            IdentifierName("Converter"),
                            LiteralExpression(SyntaxKind.NullLiteralExpression)
                        ),
                        IdentifierName("value"),
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName("Converter"),
                                IdentifierName("Convert")
                            )
                        ).WithArgumentList(
                            ArgumentList(
                                SeparatedList(
                                [
                                    Argument(IdentifierName("value")),
                                    Argument(TypeOfExpression(PredefinedType(Token(SyntaxKind.StringKeyword)))),
                                    Argument(IdentifierName("ConverterParameter")),
                                    Argument(LiteralExpression(SyntaxKind.NullLiteralExpression))
                                ])
                            )
                        )
                    )
                )
            ));

        // Build the markup extension class.
        var markupDecl = ClassDeclaration(className)
            // Inherit from MarkupExtension.
            .WithBaseList(
                BaseList(
                    SingletonSeparatedList<BaseTypeSyntax>(
                        SimpleBaseType(ParseTypeName("MarkupExtension"))
                    )
                )
            )
            .WithAttributeLists(attributes)
            .WithModifiers(TokenList(
                Token(SyntaxKind.PublicKeyword),
                Token(SyntaxKind.PartialKeyword)
            ))
            .AddMembers(
                keyEnum,
                resourceField,
                staticCtor,
                // Create the Key property.
                PropertyDeclaration(ParseTypeName("KeyEnum"), "Key")
                    .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                    .WithAccessorList(
                        AccessorList(
                            List(
                            [
                                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                                AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                            ])
                        )
                    ),
                // Create the Converter property.
                PropertyDeclaration(ParseTypeName("IValueConverter"), "Converter")
                    .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                    .WithAccessorList(
                        AccessorList(
                            List(
                            [
                                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                                AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                            ])
                        )
                    ),
                // Create the ConverterParameter property.
                PropertyDeclaration(PredefinedType(Token(SyntaxKind.ObjectKeyword)), "ConverterParameter")
                    .WithModifiers(TokenList(Token(SyntaxKind.PublicKeyword)))
                    .WithAccessorList(
                        AccessorList(
                            List(
                            [
                                AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                                AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                            ])
                        )
                    ),
                provideValueMethod
            );

        return markupDecl;
    }
}